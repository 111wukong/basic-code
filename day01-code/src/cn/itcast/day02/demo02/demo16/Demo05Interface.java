package cn.itcast.day02.demo02.demo16;

public class Demo05Interface {
    public static void main(String[] args) {
        //访问接口当中的常量
        System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS);
    }
}
/*
* 接口的内容小结:
* 1,成员变量其实是常量，格式：
* Public static final 数据类型 常量名称 = 数据值;
* 注意；
* 常量必须进行赋值，而且一旦被赋值，不能被改变
*常量名称要完全大写，用下划线进行分割
* 2.接口中最重要的就是抽象方法，格式：
* Public abstract 返回值类型 方法名称（参数列表）;
* 注意；实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。
* 3，接口里定义默认方式：格式：
* public default 返回值类型 方法名称（参数列表） {方法体}
* 注意：默认方法也可以覆盖重写
* 4，接口里定义静态方法;
* public static 返回值类型 方法名称（参数列表） {方法体}
* 注意；应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法
* 5，接口中定义私有方法：
* 普通私有方法：private 返回值类型 方法名称（参数列表）{方法体}
* 静态私有方法：private static 返回值类型 方法名称（参数列表）{方法体}
* 注意：private的方法只有接口自己才能调用，不能被实现类或者别人使用。
*
*
* 使用接口的时候需要注意：
* 1。接口是没有静态代码块或者构造方法的。
* 2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口
* 格式：
* public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{
*       覆盖重写所有的抽象方法
* }
* 3，如果实现类所实现的多个接口中，存在重复的抽象方法，那麽只需要覆盖重写一次就好了
* 4.如果实现类没有覆盖重写所有接口当中存在的抽象方法，那麽实现类一定是一个抽象类。
* 5，如果实现类所实现的多个接口中，存在重复默认的方法，那么实现类就一定要对冲突的默认方法进行覆盖重写。
* 6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先使用父类当中的方法、
*  */
